package com.worldline.quiz.core

import com.worldline.quiz.data.JokerType
import com.worldline.quiz.data.Question
import com.worldline.quiz.data.DataRepository

object GameState {
    var nodeStates = List(15) { if (it == 0) NodeState.AVAILABLE else NodeState.LOCKED }

    // La difficult√© de chaque n≈ìud est g√©n√©r√©e al√©atoirement, sauf pour le premier et le boss.
    var nodeDifficulties: List<String> = generateNodeDifficulties()

    var score = 0
    var collectedJokers = mutableListOf<JokerType>()
    var streakCount = 0
    var lastUnlockedJoker: JokerType? = null
    var allowDoubleTap = false  // Pour g√©rer le Joker Double Tap
    var currentNodeId = 0  // üî• Suivi du n≈ìud actuel

    private var currentQuestions = mutableMapOf<Int, Question>()
    private var bossQuestionList = mutableListOf<Question>()  // Questions pour le boss
    private var bossQuestionIndex = 0 // Suivi de la progression dans le combat du boss

    // üéØ Th√®me s√©lectionn√© par le joueur
    var selectedTheme: String = "G√©n√©ral"  // D√©finir un th√®me par d√©faut

    val diamondLayers = listOf(
        listOf(0),          // Layer 0
        listOf(1, 2),       // Layer 1
        listOf(3, 4, 5),    // Layer 2
        listOf(6, 7, 8),    // Layer 3
        listOf(9, 10, 11),  // Layer 4
        listOf(12, 13),     // Layer 5
        listOf(14)          // Layer 6 (boss)
    )

    init {
        generateQuestions()
    }

    /**
     * G√©n√®re al√©atoirement la difficult√© pour chaque n≈ìud.
     * Pour les n≈ìuds 1 √† 13, la difficult√© est tir√©e au hasard parmi "Facile", "Moyenne" et "Difficile".
     * Le premier n≈ìud (0) sera toujours "Facile" et le boss (14) sera toujours "Difficile".
     */
    private fun generateNodeDifficulties(): List<String> {
        val difficulties = listOf("Facile", "Moyenne", "Difficile")
        return List(15) { index ->
            when (index) {
                0 -> "Facile"
                14 -> "Difficile"
                else -> difficulties.random()
            }
        }
    }

    /**
     * Retourne la question pour le n≈ìud donn√© en se basant sur la difficult√© assign√©e √† ce n≈ìud et le th√®me s√©lectionn√©.
     */
    fun getQuestionForNode(nodeId: Int): Question {
        currentNodeId = nodeId  // üî• Mettre √† jour le n≈ìud actuel
        val difficulty = nodeDifficulties[nodeId]
        return currentQuestions[nodeId] ?: DataRepository.getRandomQuestion(selectedTheme, difficulty).also {
            currentQuestions[nodeId] = it
        }
    }

    fun getBossQuestions(): List<Question> {
        return List(3) { DataRepository.getRandomQuestion(selectedTheme, "Difficile") }
    }

    /**
     * G√©n√®re les questions pour chaque n≈ìud en fonction de la difficult√© assign√©e et du th√®me s√©lectionn√©.
     */
    fun generateQuestions() {
        currentQuestions.clear()
        for (nodeId in nodeStates.indices) {
            currentQuestions[nodeId] = DataRepository.getRandomQuestion(selectedTheme, nodeDifficulties[nodeId])
        }
        generateBossQuestions()
    }

    fun generateBossQuestions() {
        bossQuestionList.clear()
        repeat(3) {
            bossQuestionList.add(DataRepository.getRandomQuestion(selectedTheme, "Difficile"))
        }
        bossQuestionIndex = 0
    }

    fun getBossQuestion(): Question {
        return if (bossQuestionIndex < bossQuestionList.size) {
            bossQuestionList[bossQuestionIndex]
        } else {
            bossQuestionList.last()
        }
    }

    fun advanceBossQuestion(): Boolean {
        return if (bossQuestionIndex < bossQuestionList.size - 1) {
            bossQuestionIndex++
            false
        } else {
            true
        }
    }

    fun getRandomQuestion(): Question {
        return DataRepository.getRandomQuestion(selectedTheme, "Difficile")
    }

    fun reset() {
        nodeStates = List(15) { if (it == 0) NodeState.AVAILABLE else NodeState.LOCKED }
        nodeDifficulties = generateNodeDifficulties()
        score = 0
        collectedJokers.clear()
        lastUnlockedJoker = null
        allowDoubleTap = false  // R√©initialisation du Double Tap
        streakCount = 0
        generateQuestions()
    }

    fun resetForNewRun() {
        nodeStates = List(15) { if (it == 0) NodeState.AVAILABLE else NodeState.LOCKED }
        nodeDifficulties = generateNodeDifficulties()
        score = 0
        allowDoubleTap = false  // R√©initialisation du Double Tap
        generateQuestions()
    }

    fun setTheme(theme: String) {
        selectedTheme = theme
        generateQuestions() // üî• Reg√©n√©rer les questions avec le nouveau th√®me
    }

    fun unlockRandomJoker() {
        val availableJokers = JokerType.values().filter { it !in collectedJokers }
        if (availableJokers.isNotEmpty()) {
            val newJoker = availableJokers.random()
            collectedJokers.add(newJoker)
            lastUnlockedJoker = newJoker
        }
    }

    fun unlockJoker(joker: JokerType) {
        if (joker !in collectedJokers) {
            collectedJokers.add(joker)
            lastUnlockedJoker = joker
        }
    }

    fun useJoker(joker: JokerType) {
        collectedJokers.remove(joker)
        lastUnlockedJoker = null
        when (joker) {
            JokerType.DOUBLE_TAP -> allowDoubleTap = true
            JokerType.SKIP -> {
                val newQuestion = getRandomQuestion()  // ‚úÖ Correction ici
                bossQuestionList[bossQuestionIndex] = newQuestion
            }
            else -> {}
        }
    }
}
